<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Core, Version=4.0.0.0, Culture=neutral" #>
<#@ Assembly Name="Microsoft.CSharp, Version=4.0.0.0, Culture=neutral" #>

using System.Linq.Expressions;

namespace X39.Util;
public static partial class TypeExtensionMethods
{
<#
    for (var i = 1; i < 20; i++)
    {
        if (i >= 7)
        {
#>
#if NET5_0_OR_GREATER || NETSTANDARD2_0 || NETSTANDARD2_1 || NET47 || NET471 || NET472
<#
        }
#>

#if NET5_0_OR_GREATER || NETSTANDARD2_0 || NETSTANDARD2_1 || NET47 || NET471 || NET472
    private static readonly Dictionary<(
            Type,
            <#
        for (var j = 1; j <= i; j++)
        {
            Write($"Type");
            Write(j != i ? ",\r\n            " : "\r\n            ");
        }
#>), Delegate> CreateInstanceDelegate<#= i #>Cache = new(); 
#else
    private static readonly Dictionary<Tuple<
            Type,
            <#
        for (var j = 1; j <= i; j++)
        {
            Write($"Type");
            Write(j != i ? ",\r\n            " : "\r\n            ");
        }
#>>, Delegate> CreateInstanceDelegate<#= i #>Cache = new(); 
#endif
    public static object CreateInstance<<#
        for (var j = 1; j <= i; j++)
        {
            Write(j != i ? $"TArg{j}, " : $"TArg{j}");
        }
#>>(
        this Type t<#
        for (var j = 1; j <= i; j++)
        {
            Write($",\r\n        TArg{j} arg{j}");
        }
#>)
    {
#if NET5_0_OR_GREATER || NETSTANDARD2_0 || NETSTANDARD2_1 || NET47 || NET471 || NET472
        var key = (
            t,
            <#
        for (var j = 1; j <= i; j++)
        {
            Write($"typeof(TArg{j})");
            Write(j != i ? ",\r\n            " : "\r\n            ");
        }
#>);
#else
        var key = Tuple.Create(
            t,
            <#
        for (var j = 1; j <= i; j++)
        {
            Write($"typeof(TArg{j})");
            Write(j != i ? ",\r\n            " : "\r\n            ");
        }
#>);
#endif
        if (CreateInstanceDelegate<#= i #>Cache.TryGetValue(key, out var del))
            return del.DynamicInvoke(<#
        for (var j = 1; j <= i; j++)
        {
            Write($"arg{j}");
            Write(j != i ? ",\r\n            " : "\r\n            ");
        }
#>)
                ?? throw new NullReferenceException("Constructor yielded null result.");
        var constructor = t.GetConstructor(new[] {
            <#
        for (var j = 1; j <= i; j++)
        {
            Write($"typeof(TArg{j})");
            Write(j != i ? ",\r\n            " : "\r\n            ");
        }
#>});
        if (constructor == null)
        {
            var ex = new InvalidOperationException("No matching constructor existing.");
            ex.Data.Add("Target", t);
<#
        for (var j = 1; j <= i; j++)
        {
#>
            ex.Data.Add(typeof(TArg<#= j #>), arg1);
<#
        }
#>
            throw ex;
        }
        var expParameters = new Expression[] {
            <#
        for (var j = 1; j <= i; j++)
        {
            Write($"Expression.Parameter(typeof(TArg{j}))");
            Write(j != i ? ",\r\n            " : "\r\n            ");
        }
#>};
        var expNew = Expression.New(constructor, expParameters);
        CreateInstanceDelegate<#= i #>Cache[key] = del = Expression.Lambda(expNew, expParameters.Cast<ParameterExpression>()).Compile();
        var result = del.DynamicInvoke(<#
        for (var j = 1; j <= i; j++)
        {
            Write($"arg{j}");
            Write(j != i ? ",\r\n            " : "\r\n            ");
        }
#>);
        return result
               ?? throw new NullReferenceException("Constructor yielded null result.");
    }
<#
        if (i >= 7)
        {
#>
#endif
<#
        }
    }
#>
}
