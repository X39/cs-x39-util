using System.Runtime.CompilerServices;

namespace X39.Util.Collections;

/// <summary>
/// Contains extension methods for <see cref="ICollection{T}"/>
/// </summary>
[PublicAPI]
public static class CollectionExtensionMethods
{
    /// <summary>
    /// Utility method that first checks the given <paramref name="predicate"/>
    /// and only if <paramref name="predicate"/> returned true, adds the value to
    /// <paramref name="collection"/>.
    /// </summary>
    /// <param name="collection">The collection to add data to.</param>
    /// <param name="value">The value to add.</param>
    /// <param name="predicate">A function that can check, whether the value should be added.</param>
    /// <typeparam name="T">The type of the collection</typeparam>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void AddIf<T>(
        this ICollection<T> collection,
        T value,
        [InstantHandle]Func<bool> predicate)
    {
        if (predicate())
            collection.Add(value);
    }

    /// <summary>
    /// Utility method that calls <see cref="ICollection{T}.Add"/> for every element in <paramref name="range"/>.
    /// </summary>
    /// <param name="collection">The collection to add data to.</param>
    /// <param name="range">The elements to add to the <paramref name="collection"/>.</param>
    /// <typeparam name="T">The type of the collection</typeparam>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void AddRange<T>(
        this ICollection<T> collection,
        IEnumerable<T> range)
    {
        foreach (var t in range)
        {
            collection.Add(t);
        }
    }


    /// <summary>
    /// Utility method that calls <see cref="ICollection{T}.Remove"/> for every element in <paramref name="range"/>.
    /// </summary>
    /// <param name="collection">The collection to add data to.</param>
    /// <param name="range">The elements to remove from the <paramref name="collection"/>.</param>
    /// <typeparam name="T">The type of the collection</typeparam>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void RemoveRange<T>(
        this ICollection<T> collection,
        IEnumerable<T> range)
    {
        foreach (var t in range)
        {
            collection.Remove(t);
        }
    }


    /// <summary>
    /// Utility method that calls <see cref="ICollection{T}.Add"/> and then returns the <paramref name="value"/>.
    /// </summary>
    /// <param name="collection">The collection to add data to.</param>
    /// <param name="value">The element to add to the <paramref name="collection"/>.</param>
    /// <typeparam name="T">The type of the collection</typeparam>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T AddAndReturn<T>(
        this ICollection<T> collection,
        T value)
    {
        collection.Add(value);
        return value;
    }

    /// <summary>
    /// Utility method which either returns the first element or adds an element, generated by
    /// the passed <paramref name="factory"/>, and returns it.
    /// </summary>
    /// <param name="collection">The collection to add data to.</param>
    /// <param name="predicate">The predicate to check a value for.</param>
    /// <param name="factory">
    /// The factory method that generates the value
    /// added if no element matches the <paramref name="predicate"/>.
    /// </param>
    /// <typeparam name="T">The type of the collection</typeparam>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T FirstOrAdd<T>(
        this ICollection<T> collection,
        [InstantHandle]Func<T, bool> predicate,
        [InstantHandle]Func<T> factory)
    {
        var first = collection.FirstOrDefault(predicate);
        if (!EqualityComparer<T>.Default.Equals(first, default!))
            return first!;
        // ReSharper disable once ConditionIsAlwaysTrueOrFalseAccordingToNullableAPIContract
        return first is not null && predicate(first)
            ? first
            : collection.AddAndReturn(factory());
    }

    /// <summary>
    /// Utility method which either returns the first element or adds <paramref name="value"/>
    /// to the <paramref name="collection"/> and returns that.
    /// </summary>
    /// <param name="collection">The collection to add data to.</param>
    /// <param name="predicate">The predicate to check a value for.</param>
    /// <param name="value">The value added if no element matches the <paramref name="predicate"/>.</param>
    /// <typeparam name="T">The type of the collection</typeparam>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T FirstOrAdd<T>(
        this ICollection<T> collection,
        [InstantHandle]Func<T, bool> predicate,
        T value)
        where T : struct
    {
        var first = collection.FirstOrDefault(predicate);
        if (!EqualityComparer<T>.Default.Equals(first, default))
            return first;
        return predicate(first)
            ? first
            : collection.AddAndReturn(value);
    }

    /// <summary>
    /// Utility method which either returns the first element or adds an element, generated by
    /// the passed <paramref name="factory"/>, and returns it.
    /// </summary>
    /// <param name="collection">The collection to add data to.</param>
    /// <param name="predicate">The predicate to check a value for.</param>
    /// <param name="factory">
    /// The factory method that generates the value
    /// added if no element matches the <paramref name="predicate"/>.
    /// </param>
    /// <typeparam name="T">The type of the collection</typeparam>
    public static async Task<T> FirstOrAddAsync<T>(
        this ICollection<T> collection,
        [InstantHandle]Func<T, bool> predicate,
        [InstantHandle]Func<Task<T>> factory)
    {
        var first = collection.FirstOrDefault(predicate);
        if (!EqualityComparer<T>.Default.Equals(first, default!))
            return first!;
        first = await factory();
        collection.Add(first);
        return first;
    }
}